use anyhow::Result;
use crate::ast::{IdTy, Identifier};

#[derive(Debug)]
pub struct LoweredProgram {
    entries: Vec<LoweredFunction>,
}    

#[derive(Debug)]
pub struct LoweredFunction {
    pub id: IdTy,
    pub pars: Vec<IdTy>,
    pub entry: BasicBlock,
}

impl LoweredProgram {
    pub fn new(entries: Vec<LoweredFunction>) -> Self {
        Self {
            entries,
        }
    }

    pub(crate) fn get_entries(&self) -> &[LoweredFunction] {
        &self.entries
    }
}

impl LoweredFunction {
    pub fn new (id: IdTy, pars: Vec<IdTy>, entry: BasicBlock) -> Self {
        Self {
            id,
            pars,
            entry,
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct BasicBlock {
    statements: Vec<LoweredStatement>,
    next: Vec<BasicBlock>,
}

impl BasicBlock {
    pub fn empty()-> Self {
        Self {
            statements: Vec::new(),
            next: Vec::new(),
        }
    }

    pub(crate) fn get_statements(&self) -> &[LoweredStatement] {
        &self.statements
    }

    pub(crate) fn get_next(&self) -> &[BasicBlock] {
        &self.next
    }

    pub fn add_to_bottom(&mut self, stmt: LoweredStatement) -> Result<()> {
        self.statements.push(stmt);
        Ok(())
    }
}

#[derive(Debug, PartialEq)]
pub struct Variable {
    ident: Identifier,
    /// Was this variable generated by the compiler
    generated: bool,
}

impl Variable {
    pub fn new(ident: Identifier, generated: bool) -> Self {
        Self {
            ident,
            generated
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum LoweredExpression {
    Term(Term),
    Addition(Term, Box<LoweredExpression>),
}

#[derive(Debug, PartialEq)]
pub enum Term {
    I32(i32),
}

#[derive(Debug, PartialEq)]
pub enum LoweredStatement {
    Assignment(Variable, LoweredExpression),
    Phi(Variable, Vec<Variable>),
    Jump(Box<BasicBlock>),
}